# Snowman Merkle Airdrop - Findings Report

# Table of contents
- ## [Contest Summary](#contest-summary)
- ## [Results Summary](#results-summary)
- ## High Risk Findings
    - ### [H-01. Unrestricted Access to mintSnowman() Allows Arbitrary NFT Minting](#H-01)
    - ### [H-02. ECDSA TypeHash Typo Breaks Off‑Chain Signature Verification](#H-02)

- ## Low Risk Findings
    - ### [L-01. Missing Claim Check Enables Duplicate NFT Airdrops)](#L-01)
    - ### [L-02. Signature Replay Enables Duplicate NFT Claims](#L-02)


# <a id='contest-summary'></a>Contest Summary

### Sponsor: First Flight #42

### Dates: Jun 12th, 2025 - Jun 19th, 2025

[See more contest details here](https://codehawks.cyfrin.io/c/2025-06-snowman-merkle-airdrop)

# <a id='results-summary'></a>Results Summary

### Number of findings:
- High: 2
- Medium: 0
- Low: 2


# High Risk Findings

## <a id='H-01'></a>H-01. Unrestricted Access to mintSnowman() Allows Arbitrary NFT Minting            



# Root + Impact

## Description

The `mintSnowman()` function in `Snowman.sol` is used to mint Snowman NFTs and is expected to be triggered only through authorized mechanisms such as airdrops or staking rewards.

&#x20;

However, the function lacks access control and is marked `public`, allowing any address to call it directly and mint arbitrary quantities of NFTs to any wallet. This violates the protocol's NFT distribution logic.

```
solidity
```

CopyEdit

```Solidity
@function mintSnowman(address to, uint256 amount) public {
    for (uint256 i = 0; i < amount; i++) {
        uint256 newTokenId = s_tokenId++;
        _mint(to, newTokenId);
    }
}

```

This enables anyone to bypass the staking and airdrop process, minting unlimited NFTs for themselves or others without any restriction.

## Risk

**Likelihood**:

Any external account can call `mintSnowman()` with a high `amount` and mint NFTs freely.

&#x20;

* No check is performed to verify caller authorization.
* Likely to be discovered by users inspecting the ABI or contract interface.

**Impact**:

* Unauthorized NFT inflation

* Breaks the staking/airdrop trust model

* Undermines rarity and fairness of NFT supply

* Could result in economic damage or loss of user trust

## Proof of Concept

```Solidity
// This transaction can be executed by any address:
Snowman.mintSnowman(attackerAddress, 1000);

// 1000 NFTs minted without staking, claim, or reward system

```

## Recommended Mitigation

```diff

- remove this code
- function mintSnowman(address to, uint256 amount) public {
+ add this code
+ function mintSnowman(address to, uint256 amount) public onlyAirdrop {
```

## <a id='H-02'></a>H-02. ECDSA TypeHash Typo Breaks Off‑Chain Signature Verification            



Root + Impact

Description:
SnowmanAirdrop.sol uses EIP‑712 typed data for off‑chain signature verification in claimSnowman(), but the constant MESSAGE\_TYPEHASH is defined with a spelling mistake:

```solidity
bytes32 public constant MESSAGE_TYPEHASH =
    keccak256("SnowmanClaim(addres receiver, uint256 amount)");
```

The word “addres” is missing the “d”. Off‑chain signing tools build the digest for
"SnowmanClaim(address receiver, uint256 amount)" and will never match the on‑chain hash. As a result, valid signatures generated by standard libraries are rejected, blocking genuine claims and frustrating users.

Risk

Likelihood:

* Users integrating with ethers.js, web3.js or similar will generate signatures for the correct struct spelling.

* Every off‑chain signature will fail on‑chain verification.

Impact:

* All legitimate claim attempts revert with “Invalid signature.”

* Users will waste gas and submit support tickets.

* Protocol reputation suffers due to poor UX and broken claim flow.

Proof of Concept

```js
// off‑chain using ethers.js
const domain = {
  name: "SnowmanAirdrop",
  version: "1",
  chainId: 1,
  verifyingContract: AIRDROP_ADDRESS
};
const types = {
  SnowmanClaim: [
    { name: "receiver", type: "address" },
    { name: "amount",   type: "uint256" }
  ]
};
const signature = await signer._signTypedData(
  domain,
  types,
  { receiver: userAddress, amount: allocatedAmount }
);

// on‑chain recovery in claimSnowman()
await snowmanAirdrop.claimSnowman(
  userAddress,
  proof,
  v, r, s
);
// reverts with “Invalid signature”
```

Explanation:
The digest computed off‑chain uses the correct type string, so ECDSA.recover fails against the typo’d MESSAGE\_TYPEHASH.

Recommended Mitigation

```diff
- bytes32 public constant MESSAGE_TYPEHASH =
-     keccak256("SnowmanClaim(addres receiver, uint256 amount)");
+ bytes32 public constant MESSAGE_TYPEHASH =
+     keccak256("SnowmanClaim(address receiver, uint256 amount)");
```

After redeployment, update all signing scripts to use the corrected type string. Add a unit test:

```solidity
function testTypeHashConsistency() public {
    bytes32 expected = keccak256("SnowmanClaim(address receiver, uint256 amount)");
    assertEq(MESSAGE_TYPEHASH, expected, "typehash mismatch");
}
```

This ensures on‑chain and off‑chain hashes align, restoring valid signature verification and eliminating blocked claims.

    


# Low Risk Findings

## <a id='L-01'></a>L-01. Missing Claim Check Enables Duplicate NFT Airdrops)            



**Root + Impact**

**Description:**
Normally, the `claimSnowman()` function allows eligible users to claim Snowman NFTs using a Merkle proof and ECDSA signature, and is expected to be called only once per address. The contract includes a mapping `s_hasClaimedSnowman` to track this, but **does not check it before minting**.

This allows a user to re-acquire the same amount of Snow tokens and repeatedly call `claimSnowman()` using the same Merkle proof and signature. Since no check is made to prevent reclaims, they will receive NFTs multiple times, inflating their allocation and breaking the intended airdrop distribution.


```solidity
@function claimSnowman(...) {
    ...
    //  Missing check before mint
    // require(!s_hasClaimedSnowman[receiver], "Already claimed");
    _mintSnowman(receiver, balance);
    s_hasClaimedSnowman[receiver] = true;
}
```


**Risk**

**Likelihood:**

* A user with knowledge of the Merkle structure and claim logic can exploit this intentionally.
* This may also be triggered accidentally by users with rebought Snow tokens.
* Because the Merkle leaf is derived from `balanceOf()` and not a fixed snapshot, attackers can recreate valid leaves post-claim.

**Impact:**

* Multiple NFT airdrops for a single address
* Potential total supply inflation
* Reduced trust and fairness in distribution
* Users who claimed once are disadvantaged


**Proof of Concept**

```solidity
// First claim succeeds
claimSnowman(user, proof, v, r, s);

// User buys Snow tokens again
// Calls claim again with same proof + sig
claimSnowman(user, proof, v, r, s); // ❌ NFTs minted again
```

**Explanation:**
The Merkle root is based on balances. Since balances can be restored after a successful claim, the same Merkle leaf and signature remain valid again, and the function does not restrict reuse. This allows repeated claims.


**Recommended Mitigation**

```diff
+ require(!s_hasClaimedSnowman[receiver], "Already claimed");
```

**Explanation:**
This check should be added **before** minting to prevent duplicate claims. Also, consider setting the flag (`s_hasClaimedSnowman[receiver] = true`) before calling `_mintSnowman()` to avoid any risk from unexpected reentrancy, even though `nonReentrant` is applied.

## <a id='L-02'></a>L-02. Signature Replay Enables Duplicate NFT Claims            



Root + Impact

Description:
The contract constructs a Merkle leaf and verifies an ECDSA signature based only on the user’s address and token amount. There is no per‑claim nonce or timestamp included. After an initial successful claim, a user can restore their Snow token balance (via transfer or purchase) to the same amount, then reuse the identical Merkle proof and signature to call `claimSnowman()` a second time, resulting in duplicate NFT mints and supply inflation.

Key code snippet:

```Solidity
bytes32 leaf = keccak256(abi.encodePacked(receiver, amount));
require(_verify(proof, leaf), "Invalid proof");
require(_isValidSignature(receiver, amount, v, r, s), "Invalid signature");
_mintSnowman(receiver, amount);
```

***

Risk

Likelihood:

* A user able to rebuy or transfer tokens back can repeat the claim.

* No safeguard exists once proof and signature checks pass.

Impact:

* Multiple NFT airdrops to the same address.

* Airdrop supply exceeds intended distribution.

* Unfair advantage and loss of trust in the protocol.

***

Proof of Concept

1. User A holds the required `amount` of Snow tokens.
2. Call `claimSnowman(A, proof, v, r, s)` → NFTs minted (first claim).
3. Transfer or repurchase the same `amount` of Snow tokens to A.
4. Call `claimSnowman(A, proof, v, r, s)` again → NFTs minted a second time.

***

Recommended Mitigation

1. Add a per‑user nonce to leaf generation and signature:

   ```Solidity
   mapping(address => uint256) private s_nonce;
   function _leaf(address receiver, uint256 amount) internal view returns (bytes32) {
       return keccak256(abi.encodePacked(receiver, amount, s_nonce[receiver]));
   }
   ```
2. Increment nonce before verification in `claimSnowman()`:

   ```Solidity
   require(!s_hasClaimedSnowman[receiver], "Already claimed");
   s_nonce[receiver]++;
   ```
3. Retain the boolean `s_hasClaimedSnowman` check as an extra guard.
4. Update off‑chain Merkle tree and signing scripts to include the nonce in both proof generation and EIP‑712 hashing.



